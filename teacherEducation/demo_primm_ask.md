
Modelling PRIMM and 'Asking not telling'
----------------------------------------
(Modelled Lesson demo 1 hour)

(Some notes I had and left them here)
Your whole approach is just "Questions". (I will try and model this - correct me if I slip up)

* Starter
    * Log on - load python environment
        * (established routine - for today suggest you can use IDLE 3.1x 64bit)
    * In your books - new page - write the date - write the code - write your answers
    1. ```python
        for k in range(4):
            print(k)
        # Q1. What will this output?
        # Q2. What is this called?
        ```
    2. ```python
        def aa(n):
            print("I'm adding three")
            print(n + 2)
        aa(2)
        # Q3. What will this output?
        # Q4. What is `aa`?
        # Q5. Why is this bad code?
        ```
    3. If I was to "engineer a solution", what does that mean?

<details>

* Q5: Comments (I know it was a `print` and not a comment) can help readability - but they are NOT the code - probational developers write less code because the comments and code get out of sync and can lead to incorrect assumptions
</details>

* Objective
    * We are going to _reverse engineer_ some code ("Detective work")
        * > We don't know ... but we're going to find out (our motto - wall display?)
    * Understand the process/steps/questions professional engineers take to _decompose_ code
        * In our books: have a list of steps/questions (MetaCognitive Planning)
* NEXT WEEK: You will _reverse engineer_ code yourself in pairs
* Teacher Goal:
    * I can "only ask questions" or "repeat what you say"
    * (+2 new skills conveyed silently)


```python {.line-numbers}
def aa(n):
    for i in range(n):
        print('.' * (n-1-i), end='')
        print('#' * (i*2+1), end='')
        print()
```


1. What might this do? (Predict)
    * Does it matter that we don't know exactly?
2. What does this code do? (Run)
    * How would we find out what it does?
        * Run it?
3. How does it work? (Investigate)
    * Run code slowly?
    * Dry run it?
4. How would we make it better? (Modify)
    * Make it more readable?


`breakpoint()` (after `print()`) `continue` and `c`

| n | i | (n-1-i)   | (i*2+1)   | print  |
|---|---|-----------|-----------|--------|
| 4 | 0 | 4-1-0 = 3 | 0*2+1 = 1 | `   #` |
| 4 | 1 | 4-1-1 = 2 | 1*2+1 = 3 | `  ###`|
|   | 2 |           |           |        |


* Summary
    1. What steps/questions/process do we take to _reverse engineer_ code?
    2. What were the two new skills we learnt?
        * What is `breakpoint()`?
        * What is DryRun?
    3. What key terms have we covered?
        * what does that mean?
    4. What are we going to do next lesson?
    5. MetaCognition
        * What was hard this lesson? How will you do things differently next lesson?


<details>

* How would we make it better? (Modify)
    * Slightly different values?
    
* What additions could we make?
    * How can we make those additions?



* How does it work?
    * What does the `for` do?
    * What does `"#"*5` do
* How would we make it better?
    * Rename the function or variables to be more descriptive
* What additions could we make?
    * change `#` to another `^`
    * How would be "Make it a diamond"? (inverse bottom)
    * Make each line have a start and end `<--->`
    * Omega advanced - contaminated with output - return a string

* Is this 'constructivism' why? why not?
* Why is the example above effective?
    * Delivery?
    * code
        * visual (in terminal)
        * No branching/if/comparisons 
            * limiting the scope to this activity to purely focus on approach to code comprehension (dry run, bounded iteration)

* See also [[block_model]]
</details>


[//begin]: # "Autogenerated link references for markdown compatibility"
[block_model]: block_model.md "block_model"
[//end]: # "Autogenerated link references"